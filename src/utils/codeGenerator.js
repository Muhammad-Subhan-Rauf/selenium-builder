// relative path: utils/codeGenerator.js

import { handlers as pythonHandlers } from './generator/blockHandlers';
import { cypressHandlers } from './generator/cypressHandlers';
import { getNextNode } from './generator/helpers';

// --- TEMPLATES ---

const PYTHON_IMPORTS = `import unittest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import datetime
import os
import sys
from colorama import init, Fore, Back, Style

init(autoreset=True)

# Helper functions would go here (omitted for brevity, same as before)
def log_step(msg): print(f"{Fore.YELLOW}[STEP] {msg}{Style.RESET_ALL}")
def log_pass(msg): print(f"{Fore.GREEN}[PASS] {msg}{Style.RESET_ALL}")
def log_fail(msg): print(f"{Fore.RED}[FAIL] {msg}{Style.RESET_ALL}")
`;

// Dynamic header generator for Python/Selenium
const getPythonHeader = (startNode) => {
    let setUpContent = '        self.vars = {}\n';

    // Add cleanup commands based on startNode settings
    if (startNode.data.clearCookies) {
        setUpContent += '        # Clear cookies will be called after driver init in test method\n';
    }
    if (startNode.data.clearLocalStorage) {
        setUpContent += '        # Clear localStorage will be called after driver init in test method\n';
    }

    return PYTHON_IMPORTS + `
class TestSuite(unittest.TestCase):
    def setUp(self):
${setUpContent}`;
};

// Dynamic header generator for Cypress
const getCypressHeader = (startNode) => {
    let beforeEachContent = '        Cypress.env({});\n';

    // Add cleanup commands based on startNode settings
    if (startNode.data.clearCookies) {
        beforeEachContent += '        cy.clearCookies();\n';
    }
    if (startNode.data.clearLocalStorage) {
        beforeEachContent += '        cy.clearLocalStorage();\n';
    }
    if (startNode.data.clearSessionStorage) {
        beforeEachContent += '        cy.clearAllSessionStorage();\n';
    }

    return `// Generated by Visual Builder
describe('Visual Flow Tests', () => {
    beforeEach(() => {
${beforeEachContent}    });
`;
};

// Legacy static headers for backward compatibility
const PYTHON_HEADER = PYTHON_IMPORTS + `
class TestSuite(unittest.TestCase):
    def setUp(self):
        self.vars = {}
`;

const CYPRESS_HEADER = `// Generated by Visual Builder
describe('Visual Flow Tests', () => {
    beforeEach(() => {
        Cypress.env({});
    });
`;

// Helper: Sanitize string for filenames and function names
const sanitize = (str) => {
    if (!str) return 'test_case';
    // Replace spaces/symbols with underscores, remove weird chars, lowercase
    return str.replace(/[^a-z0-9]/gi, '_').toLowerCase();
};

// --- SINGLE TEST GENERATOR ---

const generateSingleTestContent = (startNode, nodes, edges, framework) => {
    const isCypress = framework === 'cypress';
    const handlers = isCypress ? cypressHandlers : pythonHandlers;
    
    // 1. Get Test Name
    const rawName = startNode.data.testName || 'Untitled Test';
    const safeName = sanitize(rawName);
    const url = startNode.data.url || 'https://example.com';
    const browser = startNode.data.browser || 'Chrome';

    let code = '';

    // 2. Build recursive processor for THIS start node's chain
    const processNode = (node, indentLevel, visited = new Set()) => {
        if (!node) return '';
        if (visited.has(node.id)) return `${'    '.repeat(indentLevel)}// Cycle detected\n`;
        
        const newVisited = new Set(visited);
        newVisited.add(node.id);
        const indent = '    '.repeat(indentLevel);
        
        const context = {
            nodes, edges, indentLevel, indent,
            processNodeFn: (n, lvl) => processNode(n, lvl, newVisited),
            processNext: (nCurrent) => {
                const next = getNextNode(nCurrent, edges, nodes);
                if (next) return processNode(next, indentLevel, newVisited);
                return '';
            }
        };

        const handler = handlers[node.type];
        return handler ? handler(node, context) : `${indent}# Unknown node ${node.type}\n`;
    };

    // 3. Construct File Content
    if (isCypress) {
        code = getCypressHeader(startNode);
        code += `    it('${rawName}', () => {\n`;
        code += `        cy.visit('${url}');\n`;
        code += processNode(startNode, 2);
        code += `    });\n});`; // End it, End describe
    } else {
        code = getPythonHeader(startNode);
        code += `    def test_${safeName}(self):\n`; // Python tests must start with 'test_'
        code += `        print("Running ${rawName}")\n`;
        code += `        driver = webdriver.${browser}()\n`;
        code += `        driver.get("${url}")\n`;
        // Add cleanup commands after driver init for Selenium
        if (startNode.data.clearCookies) {
            code += `        driver.delete_all_cookies()\n`;
        }
        if (startNode.data.clearLocalStorage) {
            code += `        driver.execute_script("window.localStorage.clear();")\n`;
        }
        code += processNode(startNode, 2);
        code += `        driver.quit()\n`;
        code += `\nif __name__ == "__main__":\n    unittest.main()`;
    }

    return code;
};

// --- MAIN EXPORT FUNCTION ---

export const generateSuite = (nodes, edges) => {
    const startNodes = nodes.filter(n => n.type === 'start_session');
    
    if (startNodes.length === 0) return [];

    return startNodes.map((startNode, index) => {
        const framework = startNode.data.framework || 'selenium';
        const rawName = startNode.data.testName || `test_case_${index + 1}`;
        const safeName = sanitize(rawName);
        
        // Determine Extension
        const ext = framework === 'cypress' ? 'spec.cy.js' : 'py';
        
        // Generate Content
        const content = generateSingleTestContent(startNode, nodes, edges, framework);

        return {
            filename: `${safeName}.${ext}`,
            content: content,
            framework: framework
        };
    });
};

// Keep old function for backwards compatibility if needed, but we won't use it in App.jsx
export const generateCode = (nodes, edges) => {
    const suite = generateSuite(nodes, edges);
    return suite.map(f => `// --- FILE: ${f.filename} ---\n${f.content}`).join('\n\n');
};